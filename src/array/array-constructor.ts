import { defineStaticIfNotExists } from '../utils';

export {};

declare global {
    interface ArrayConstructor {
        /**
         * Combines multiple arrays element-wise, similar to Python's `itertools.zip_longest`.
         *
         * @example
         * Array.zip([1, 2], ['a', 'b', 'c']);
         * // => [[1, 'a'], [2, 'b'], [undefined, 'c']]
         *
         * @template T Type of the array elements
         * @param {...T[][]} arrays Arrays to zip together
         * @returns {Array<(T | undefined)[]>} A new array where each element is an array containing the elements at the same index from each input array. Missing elements are `undefined`.
         */
        zip(...arrays: any[][]): any[][];

        /**
         * Generates a sequence of numbers, similar to Python's `range`.
         *
         * @example
         * Array.range(5);
         * // => [0, 1, 2, 3, 4]
         *
         * @example
         * Array.range(2, 10, 2);
         * // => [2, 4, 6, 8]
         *
         * @param {number} start First number, or the length if `end` is not provided
         * @param {number} [end] Last number (excluded)
         * @param {number} [step=1] Step between numbers (can be negative)
         * @returns {number[]} An array containing the generated sequence
         */
        range(start: number, end?: number, step?: number): number[];

        /**
         * Creates an array filled with the same value or with values generated by a factory function.
         *
         * @example
         * Array.repeat(3, 'x');
         * // => ['x', 'x', 'x']
         *
         * @example
         * Array.repeat(3, () => Math.random());
         * // => [0.12, 0.45, 0.78] (values will differ)
         *
         * @template T Type of the array elements
         * @param {number} length Length of the array (must be a non-negative integer)
         * @param {T | (() => T)} value Value or function generating the value
         * @returns {T[]} The filled array
         */
        repeat<T>(length: number, value: T | (() => T)): T[];

        /**
         * Creates an array filled with a given value or generated using a factory function.
         * Supports creating multi-dimensional arrays by passing multiple sizes.
         *
         * @example
         * // 1D array with primitive values
         * const arr1 = Array.create('x', 5);
         * // type: string[]
         * // value: ['x', 'x', 'x', 'x', 'x']
         *
         * @example
         * // 1D array with random numbers
         * const arr2 = Array.create(() => Math.random(), 5);
         * // type: number[]
         * // value: [0.12, 0.87, 0.45, 0.76, 0.33] (values will differ)
         *
         * @example
         * // 2D array (matrix)
         * const arr3 = Array.create(0, 2, 3);
         * // type: number[][]
         * // value: [[0, 0, 0], [0, 0, 0]]
         *
         * @example
         * // 2D array with distinct objects
         * const arr4 = Array.create(() => ({ id: 0 }), 2, 3);
         * // type: { id: number }[][]
         * // value: [
         * //   [{ id: 0 }, { id: 0 }, { id: 0 }],
         * //   [{ id: 0 }, { id: 0 }, { id: 0 }]
         * // ]
         *
         * @notes
         * - If `sizes.length === 0`, returns `[]`.
         * - If `valueOrFactory` is a primitive, all cells contain the same value.
         * - If `valueOrFactory` is a function, it is called for each cell to produce a fresh value.
         * - `sizes` should be integers >= 0; negative or non-integer values are not supported.
         *
         * @template T
         * @param {T | (() => T)} valueOrFactory The value to fill the array with, or a factory function producing values.
         * @param {...number} sizes Sizes for each dimension (1D => one number, 2D => two numbers, etc.).
         * @returns {Array} A multi-dimensional array of the specified depth filled with the given values.
         *
         * @remarks
         * - This method is **static** and must be called on `Array`, not on an instance.
         */
        create<T, Dims extends number[]>(
            valueOrFactory: T | (() => T),
            ...sizes: Dims
        ): MultiDimensionalArray<WidenLiterals<T>, Dims>;
    }
}

/**
 * @see Array.zip
 */
defineStaticIfNotExists(Array, 'zip', function <T>(...arrays: T[][]): Array<(T | undefined)[]> {
    if (arrays.length === 0) return [];
    const maxLen = Math.max(...arrays.map((arr) => arr.length));
    return Array.from({ length: maxLen }, (_, i) => arrays.map((arr) => arr[i]));
});

/**
 * @see Array.range
 */
defineStaticIfNotExists(Array, 'range', function (start: number, end?: number, step = 1): number[] {
    if (end === undefined) {
        end = start;
        start = 0;
    }
    if (step === 0) throw new Error('step must not be 0');
    const result: number[] = [];
    const condition = step > 0 ? (i: number) => i < end! : (i: number) => i > end!;
    for (let i = start; condition(i); i += step) {
        result.push(i);
    }
    return result;
});

/**
 * @see Array.repeat
 */
defineStaticIfNotExists(Array, 'repeat', function <T>(length: number, value: T | (() => T)): T[] {
    if (typeof length !== 'number' || !Number.isInteger(length) || length < 0) {
        throw new TypeError('Length must be a non-negative integer');
    }
    return Array.from({ length }, () => (typeof value === 'function' ? (value as () => T)() : value));
});

/**
 * @see Array.create
 */
defineStaticIfNotExists(Array, 'create', function <
    T,
    Dims extends number[],
>(valueOrFactory: T | (() => T), ...sizes: Dims): MultiDimensionalArray<WidenLiterals<T>, Dims> {
    if (sizes.length === 0) return [] as any;
    if (!sizes.every((s) => Number.isInteger(s) && s >= 0)) {
        throw new TypeError('All sizes must be non-negative integers');
    }
    const getValue = typeof valueOrFactory === 'function' ? (valueOrFactory as () => T) : () => valueOrFactory;
    const createDimension = (dimIndex: number): any =>
        Array.from({ length: sizes[dimIndex] }, () =>
            dimIndex === sizes.length - 1 ? getValue() : createDimension(dimIndex + 1),
        );
    return createDimension(0);
});

type MultiDimensionalArray<T, Dims extends number[]> = Dims extends [number, ...infer Rest extends number[]]
    ? MultiDimensionalArray<T[], Rest>
    : T;
type WidenLiterals<T> = T extends string ? string : T extends number ? number : T extends boolean ? boolean : T;
